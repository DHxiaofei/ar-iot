/*
 * protocol.c
 *
 *  Created on: May 4, 2017
 *      Author: ken
 */

#include <stdio.h>
#include <string.h>
#include "protocol.h"


static int get_one_char(protocol_list_t *_list, uint8_t * _data);
static int default_do_cmd(uint8_t *protocol, int _len);

void protocol_list_init(protocol_list_t *_list, uint8_t *_buf, int _buf_len)
{
	_list->head = 0;
	_list->tail = 0;
	_list->max_len = _buf_len;
	_list->count = 0;
	_list->ring_buf = _buf;
}

/**
 *
 * @return the bcc value
 */
uint8_t calc_bcc(uint8_t *_buf, int _len)
{
	int i = 0;
	uint8_t check = 0;
	for (i=0; i<_len; i++)
	{
		check ^= _buf[i];
	}
	return check;
}


int put_data_to_list(protocol_list_t *_list, const uint8_t *_data, int _len)
{
	int capacity = 0, min_len = 0;
	const uint8_t *data = _data;

	do
	{
		capacity = _list->max_len - _list->tail;
		min_len =  _len<capacity ? _len : capacity;
		memcpy(_list->ring_buf+_list->tail, data, min_len);
		_list->tail += min_len;
		if (_list->tail >= _list->max_len) _list->tail = 0;
		data += min_len;
		_len -= min_len;
	}while(_len>0);
	return _len;
}

/**
 * @brief
 * @_list
 * @_package the package which get from _list
 * @return the len of _package
 */
int get_one_package(protocol_list_t *_list, uint8_t *_package, int _len)
{
	uint16_t count = 0;
	uint8_t temp = 0;
	int err = 0;


	while (1)
	{
		err = get_one_char(_list, &temp);
		if (err < 0)
		{
			return -2;//try again
		}

		switch (temp) {

		/* if it's an END character then we're done with
		 * the packet
		 */
		case SLIP_END:
			/* a minor optimization: if there is no
			 * data in the packet, ignore it. This is
			 * meant to avoid bothering IP with all
			 * the empty packets generated by the
			 * duplicate END characters which are in
			 * turn sent to try to detect line noise.
			 */
			if (count)
			{
				return count;
			}
			else
			{
				break;
			}

			/* if it's the same code as an ESC character, wait
			 * and get another character and then figure out
			 * what to store in the packet based on that.
			 */
		case SLIP_ESC:
			err = get_one_char(_list, &temp);
			if (err < 0)
			{
				return -2;//try again
			}
			//taskEXIT_CRITICAL();

			/* if "c" is not one of these two, then we
			 * have a protocol violation.  The best bet
			 * seems to be to leave the byte alone and
			 * just stuff it into the packet
			 */
			switch (temp) {
			case SLIP_ESC_END:
				temp = SLIP_END;
				break;
			case SLIP_ESC_ESC:
				temp = SLIP_ESC;
				break;
			}
			// Store the character
			if (count < _len) {
				_package[count++] = temp;
			}
			break;
		default:
			// Store the character
			if (count < _len) {
				_package[count++] = temp;
			}
		}
	}

}


/**
 *
 */
int parase_protocol(protocol_list_t *_list, int (*do_cmd)(uint8_t *_protocol, int _len))
{
	static uint8_t protocol_buf[MAX_RECEIVE_BUF_LEN];
	int len = 0;

	if (do_cmd == NULL)
	{
		do_cmd = default_do_cmd;
	}

	len = get_one_package(_list, protocol_buf, MAX_RECEIVE_BUF_LEN);
	printf("parase_protocol -- get_one_package : %d \n", len);
	if (len < 0)
	{
		return len;
	}

	//check bcc
	/*
	if (protocol_buf[len] != calc_bcc(protocol_buf, len-1))
	{
		printf("CHECK bcc error\n");
		return -1;//check error
	}
	*/
	return do_cmd(protocol_buf, len);
}


int protocol_send(uint8_t *_protocol, int _len)
{
#if 0
	uint8_t temp = SLIP_END;
	int i = 0;

	HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
	for (i=0; i<_len; i++)
	{
		if (_protocol[i] == SLIP_END)
		{
			temp = SLIP_ESC;
			HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
			temp = SLIP_ESC_END;
			HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
		}
		else if (_protocol[i] == SLIP_ESC)
		{
			temp = SLIP_ESC;
			HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
			temp = SLIP_ESC_ESC;
			HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
		}
		else
		{
			temp = _protocol[i];
			HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
		}
	}
	temp = SLIP_END;
	HAL_UART_Transmit(&huart2, &temp, sizeof(temp), 1000);
#endif
	return _len;
}

uint32_t uint32_to_big(uint32_t value)
{
	uint8_t src[4];

	src[0] = ((value >> 24) & 0xFF);
	src[1] = ((value >> 16) & 0xFF);
	src[2] = ((value >> 8) & 0xFF);
	src[3] = ((value) & 0xFF);
	return *(uint32_t *)src;
}

uint16_t uint16_to_big(uint16_t value)
{
	uint8_t src[2];

	src[0] = ((value >> 8) & 0xFF);
	src[1] = ((value) & 0xFF);
	return *(uint16_t *)src;
}

uint32_t big_to_uint32(uint32_t *value)
{
	uint8_t *pvalue = (uint8_t *)value;

	return (uint32_t) (pvalue[0]<<24 |
					pvalue[1]<<16 |
					pvalue[2]<<8  |
					pvalue[3]);
}

uint16_t big_to_uint16(uint16_t *value)
{
	uint8_t *pvalue = (uint8_t *)value;
	return (uint16_t) (pvalue[0]<<8 |
					pvalue[1]);
}

//--------------- static function ---------------
//-----------------------------------------------
//-------------------------------------------------


/**
 * @brief get one data form ring buf of protocol head
 * @_data
 * @return 0 if get success
 */
static int get_one_char(protocol_list_t *_list, uint8_t * _data)
{
	uint16_t time_out = 0;
	while (time_out < 1000)
	{
		time_out++;
		if (_list->head < _list->tail)
		{
			*_data = _list->ring_buf[_list->head];
			++_list->head;
			return 0;
		}
		else if (_list->head == _list->tail)
		{
			continue;
		}
		else
		{
			*_data = _list->ring_buf[_list->head];
			if (_list->head >= _list->max_len)
			{
				_list->head = 0;
			}
			else
			{
				++_list->head;
			}
			return 0;
		}
	}
	return -1;//time out
}

static int default_do_cmd(uint8_t *protocol, int _len)
{

}

